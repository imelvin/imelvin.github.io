
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>java.util.concurrent.ConcurrentHashMap原理研究 | Elvin Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Elvin Guan">
    
    <meta name="description" content="ConcurrentHashMap是Java并发程序中一个很常用的类，本文旨在研究散列结构的原理和ConcurrentHashMap的性能优化技术。
首先我们先自己实现一个简单的MyHashMap，然后实现线程安全的MyConcurrentHashMap，最后分析java.util.concurre">
    
    
    
    
    <link rel="alternative" href="/atom.xml" title="Elvin Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">

</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Elvin Blog" title="Elvin Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Elvin Blog">Elvin Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:elvin.im">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/04/17/java-util-concurrent-ConcurrentHashMap原理研究/" title="java.util.concurrent.ConcurrentHashMap原理研究" itemprop="url">java.util.concurrent.ConcurrentHashMap原理研究</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://elvin.im/about" title="Elvin Guan" target="_blank" itemprop="author">Elvin Guan</a>
		
  <p class="article-time">
    <time datetime="2016-04-16T17:57:17.000Z" itemprop="datePublished"> 发表于 4月 17 2016</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#非线程安全HashMap"><span class="toc-number">1.</span> <span class="toc-text">非线程安全HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实现MyHashMap"><span class="toc-number">1.1.</span> <span class="toc-text">实现MyHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#put方法性能"><span class="toc-number">1.2.</span> <span class="toc-text">put方法性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自适应容量优化"><span class="toc-number">1.3.</span> <span class="toc-text">自适应容量优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get方法性能"><span class="toc-number">1.4.</span> <span class="toc-text">get方法性能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程安全的HashMap"><span class="toc-number">2.</span> <span class="toc-text">线程安全的HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#改造MyHashMap为线程安全"><span class="toc-number">2.1.</span> <span class="toc-text">改造MyHashMap为线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试MyHashtable性能"><span class="toc-number">2.2.</span> <span class="toc-text">测试MyHashtable性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现MyConcurrentHashMap"><span class="toc-number">2.3.</span> <span class="toc-text">实现MyConcurrentHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试结果异常分析"><span class="toc-number">2.4.</span> <span class="toc-text">测试结果异常分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java-util-concurrent-ConcurrentHashMap源码分析"><span class="toc-number">3.</span> <span class="toc-text">java.util.concurrent.ConcurrentHashMap源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#concurrentLevel"><span class="toc-number">3.1.</span> <span class="toc-text">concurrentLevel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#putOrderedObject"><span class="toc-number">3.2.</span> <span class="toc-text">putOrderedObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更充分的hash"><span class="toc-number">3.3.</span> <span class="toc-text">更充分的hash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Segment的put方法"><span class="toc-number">3.4.</span> <span class="toc-text">Segment的put方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自旋等等锁"><span class="toc-number">3.5.</span> <span class="toc-text">自旋等等锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get方法"><span class="toc-number">3.6.</span> <span class="toc-text">get方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#size方法"><span class="toc-number">3.7.</span> <span class="toc-text">size方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol>
		
		</div>
		
		<p>ConcurrentHashMap是Java并发程序中一个很常用的类，本文旨在研究散列结构的原理和ConcurrentHashMap的性能优化技术。</p>
<p>首先我们先自己实现一个简单的MyHashMap，然后实现线程安全的MyConcurrentHashMap，最后分析java.util.concurrent.ConcurrentHashMap的源码</p>
<h2 id="非线程安全HashMap">非线程安全HashMap</h2>
<h3 id="实现MyHashMap">实现MyHashMap</h3>
<p>首先定义一个MyMap的接口如下：</p>
<figure class="highlight [Java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">interface</span> MyMap&lt;K, V&gt; {</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> V <span class="title">put</span>(K key, V <span class="keyword">value</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> V <span class="title">remove</span>(Object key);</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span>();</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> V <span class="title">get</span>(Object key);</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span>();</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> boolean <span class="title">isEmpty</span>();</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> Entry&lt;K, V&gt; {</div><div class="line">        <span class="keyword">public</span> K <span class="title">getKey</span>();</div><div class="line">        </div><div class="line">        <span class="keyword">public</span> V <span class="title">getValue</span>();</div><div class="line">        </div><div class="line">        <span class="keyword">public</span> V <span class="title">setValue</span>(V <span class="keyword">value</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>为了简单起见，MyHashMap使用一个固定的数组来保存bucket，每个bucket是一个链表，关键的put和get方法如下：</p>
<figure class="highlight [Java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line"><span class="keyword">public</span> V <span class="title">put</span>(K key, V <span class="keyword">value</span>) {</div><div class="line">    <span class="keyword">return</span> putVal(hash(key), key, <span class="keyword">value</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// put方法通过hashCode将key映射到table数组上，如果出现冲突则往链表插入节点</span></div><div class="line"><span class="keyword">private</span> V <span class="title">putVal</span>(<span class="keyword">int</span> hash, K key, V <span class="keyword">value</span>) {</div><div class="line">    <span class="keyword">int</span> i = (table.length - <span class="number">1</span>) & hash;</div><div class="line">    Node&lt;K, V&gt; p = <span class="keyword">this</span>.table[i];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) {</div><div class="line">        p = <span class="keyword">this</span>.table[i] = <span class="keyword">new</span> Node&lt;&gt;(hash, key, <span class="keyword">value</span>, <span class="keyword">null</span>);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">if</span> (p.hash == hash && (p.key == key || (key != <span class="keyword">null</span> && key.equals(p.key)))) {</div><div class="line">                p.<span class="keyword">value</span> = <span class="keyword">value</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (p.next == <span class="keyword">null</span>) {</div><div class="line">                p = p.next = newNode(hash, key, <span class="keyword">value</span>, <span class="keyword">null</span>);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            }</div><div class="line">            p = p.next;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">this</span>.size ++;</div><div class="line">    <span class="keyword">return</span> p.<span class="keyword">value</span>;</div><div class="line">}</div><div class="line"></div><div class="line">@Override</div><div class="line"><span class="keyword">public</span> V <span class="title">get</span>(Object key) {</div><div class="line">    Node&lt;K, V&gt; e;</div><div class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.<span class="keyword">value</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// get方法通过hashCode在数组中找到相应的bucket，再遍历查找相应的key</span></div><div class="line"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title">getNode</span>(<span class="keyword">int</span> hash, Object key) {</div><div class="line">    <span class="keyword">int</span> i = (table.length - <span class="number">1</span>) & hash;</div><div class="line">    Node&lt;K, V&gt; first;</div><div class="line">    Node&lt;K, V&gt; p;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ((first = <span class="keyword">this</span>.table[i]) != <span class="keyword">null</span>) {</div><div class="line">        p = first;</div><div class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">if</span> (p.hash == hash && (p.key == key || (key != <span class="keyword">null</span> && key.equals(p.key)))) {</div><div class="line">                <span class="keyword">return</span> p;</div><div class="line">            }</div><div class="line">            </div><div class="line">            p = p.next;</div><div class="line">        }</div><div class="line">    }</div><div class="line">        </div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="put方法性能">put方法性能</h3>
<p>然后写一个测试用例来测试put方法的性能，测试用例如下：</p>
<figure class="highlight [Java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> MyHashMapTest {</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> MyMap&lt;String, Integer&gt; myMap = <span class="keyword">new</span> MyHashMap&lt;&gt;();</div><div class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10000</span>;</div><div class="line">    </div><div class="line">    @Test</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMyHashMap</span>() {</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) {</div><div class="line">            myMap.put(String.valueOf(i), i);</div><div class="line">        }</div><div class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"MyHashMap耗时："</span> + (end - start));</div><div class="line">    }</div><div class="line">    </div><div class="line">    @Test</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHashMap</span>() {</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) {</div><div class="line">            map.put(String.valueOf(i), i);</div><div class="line">        }</div><div class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"HashMap耗时："</span> + (end - start));</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<pre><code>当<span class="built_in">count</span> = <span class="number">10000</span>时，测试结果如下：
    MyHashMap耗时：<span class="number">58</span>
    HashMap耗时：<span class="number">5</span>

当<span class="built_in">count</span> = <span class="number">100000</span>时，测试结果如下：
    MyHashMap耗时：<span class="number">20114</span>
    HashMap耗时：<span class="number">32</span>
</code></pre><h3 id="自适应容量优化">自适应容量优化</h3>
<p>由结果可见我们自己实现的MyHashMap性能差很多，经过初步分析原因如下：</p>
<ul>
<li>bucket数量不变，当数据量足够大时，会有很多冲突，每次put都是一个链表的遍历</li>
</ul>
<p>我们可以动态的增加bucket数量，保证冲突不会太多。</p>
<p>根据以上思路，我们加入了resize方法，每当Map元素数量达到临界值时就扩充一倍的容量。</p>
<figure class="highlight [Java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Node&lt;K, V&gt; [] resize() {</div><div class="line">    Node&lt;K, V&gt; [] newTab = table;</div><div class="line">    <span class="keyword">int</span> oldCap = table.length;</div><div class="line">    <span class="keyword">int</span> newCap;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">size</span> &gt; threshold) {    <span class="comment">//超过临界值，增加容量</span></div><div class="line">        <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; <span class="number">0</span>) {</div><div class="line">            newCap = Integer.MAX_VALUE;</div><div class="line">        }</div><div class="line">        threshold = (<span class="keyword">int</span>) (loadFactor * newCap);</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (newCap &gt; oldCap) {</div><div class="line">            newTab = (Node&lt;K, V&gt; []) <span class="keyword">new</span> Node [newCap];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; table.length; i++) {</div><div class="line">                Node&lt;K, V&gt; e = table[i];</div><div class="line">                <span class="keyword">while</span> (e != <span class="keyword">null</span>) {</div><div class="line">                    Node&lt;K, V&gt; p = e;</div><div class="line">                    e = e.<span class="keyword">next</span>;</div><div class="line">                    <span class="keyword">int</span> j = p.hash & (newCap - <span class="number">1</span>);</div><div class="line">                    Node&lt;K, V&gt; q = newTab[j];</div><div class="line">                    p.<span class="keyword">next</span> = q;</div><div class="line">                    newTab[j] = p;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">        </div><div class="line">    <span class="keyword">this</span>.table = newTab;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> newTab;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>经过此优化后，</p>
<pre><code><span class="built_in">count</span> = <span class="number">10000</span>时，测试结果如下：
    MyHashMap耗时：<span class="number">11</span>
    HashMap耗时：<span class="number">7</span>


当<span class="built_in">count</span> = <span class="number">100000</span>时，测试结果如下：
    MyHashMap耗时：<span class="number">59</span>
    HashMap耗时：<span class="number">39</span>
</code></pre><p>可以看到，性能已经明显好转，已经与Java的HashMap的性能在一个量级。</p>
<h3 id="get方法性能">get方法性能</h3>
<p>将测试用例稍微改写一点</p>
<figure class="highlight [Java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> MyHashMapTest {</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> MyMap&lt;String, Integer&gt; myMap = <span class="keyword">new</span> MyHashMap&lt;&gt;();</div><div class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10000</span>;</div><div class="line">    </div><div class="line">    @Test</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMyHashMap</span>() {</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) {</div><div class="line">            myMap.put(String.valueOf(i), i);</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) {</div><div class="line">            assertNotNull(myMap.<span class="keyword">get</span>(String.valueOf(i)));</div><div class="line">        }</div><div class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"MyHashMap耗时："</span> + (end - start));</div><div class="line">    }</div><div class="line">    </div><div class="line">    @Test</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHashMap</span>() {</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) {</div><div class="line">            map.put(String.valueOf(i), i);</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) {</div><div class="line">            assertNotNull(map.<span class="keyword">get</span>(String.valueOf(i)));</div><div class="line">        }</div><div class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"HashMap耗时："</span> + (end - start));</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>测试结果如下，</p>
<pre><code>当<span class="built_in">count</span> = <span class="number">10000</span>时
    MyHashMap耗时：<span class="number">22</span>
    HashMap耗时：<span class="number">4</span>

当<span class="built_in">count</span> = <span class="number">100000</span>时
    MyHashMap耗时：<span class="number">22</span>
    HashMap耗时：<span class="number">25</span>

当<span class="built_in">count</span> = <span class="number">1000000</span>时
    MyHashMap耗时：<span class="number">1121</span>
    HashMap耗时：<span class="number">118</span>

当<span class="built_in">count</span> = <span class="number">10000000</span>
    MyHashMap耗时：<span class="number">2698</span>
    HashMap耗时：<span class="number">2737</span>
</code></pre><p>当测试充分时，MyHashMap与java.util.HashMap的性能差距有限。</p>
<h2 id="线程安全的HashMap">线程安全的HashMap</h2>
<h3 id="改造MyHashMap为线程安全">改造MyHashMap为线程安全</h3>
<p>在多线程情况下，MyHashMap就不能再使用，MyHashMap没有任何线程安全措施，强行使用的话会导致不可预知的结果发生，java.util.HashMap同理。而在Java中，与java.util.HashMap对应的线程安全类是java.util.Hashtable，Hashtable在HashMap基础上加入了线程同步，所以线程是安全的。</p>
<p>现在我们重新实现一个MyHashtable，在MyHashMap的基础上加入线程安全措施。</p>
<figure class="highlight [Java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHashtable</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">MyMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>{</div><div class="line"></div><div class="line">    ......    </div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span>(K key, V value) {</div><div class="line">        <span class="keyword">return</span> putVal(hash(key), key, value);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">remove</span>(Object key) {</div><div class="line">        Node&lt;K, V&gt; e;</div><div class="line">        <span class="keyword">return</span> (e = removeNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clear</span>() {</div><div class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) {</div><div class="line">            size = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; table.length; i++) {</div><div class="line">                table[i] = <span class="keyword">null</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span>(Object key) {</div><div class="line">        Node&lt;K, V&gt; e;</div><div class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span>() {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span>() {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size == <span class="number">0</span>;</div><div class="line">    }</div><div class="line">    </div><div class="line">    ......</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="测试MyHashtable性能">测试MyHashtable性能</h3>
<p>我们使用一个线程数量为100的线程池来测试散列结构的并发性能，在每个线程中读写散列结构1000次。然后再分别测试java.util.Hashtable、java.util.concurrent.ConcurrentHashMap性能作为对比。测试代码如下：</p>
<figure class="highlight [Java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHashMapMultiThreadTest</span> </span>{</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> ThreadPoolExecutor threadPool;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyMap&lt;String, Integer&gt; myTable = <span class="keyword">new</span> MyHashtable&lt;&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Integer&gt; table = <span class="keyword">new</span> Hashtable&lt;&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Integer&gt; conMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">1000000</span>; </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nThread = Runtime.getRuntime().availableProcessors() + <span class="number">1</span>;</div><div class="line">    </div><div class="line">    <span class="annotation">@Before</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span>() {</div><div class="line">        threadPool = <span class="keyword">new</span> ThreadPoolExecutor(nThread, nThread, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Test</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMyHashTable</span>() <span class="keyword">throws</span> InterruptedException {</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThread; i++) {</div><div class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() {</div><div class="line">                </div><div class="line">                <span class="annotation">@Override</span></div><div class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j++) {</div><div class="line">                        <span class="keyword">int</span> num = xorShift(<span class="keyword">this</span>.hashCode() ^ (<span class="keyword">int</span>) System.nanoTime());</div><div class="line">                        myTable.put(String.valueOf(num), numj), j);</div><div class="line">                    }</div><div class="line">                    </div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j++) {</div><div class="line">                        <span class="keyword">int</span> num = xorShift(<span class="keyword">this</span>.hashCode() ^ (<span class="keyword">int</span>) System.nanoTime());</div><div class="line">                        myTable.get(String.valueOf(numj));</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            });</div><div class="line">        }</div><div class="line">        </div><div class="line">        threadPool.shutdown();</div><div class="line">        <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">while</span> (loop) {</div><div class="line">            loop = !threadPool.awaitTermination(<span class="number">100</span>, TimeUnit.MILLISECONDS);</div><div class="line">        }</div><div class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"MyHashtable耗时："</span> + (end - start));</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="annotation">@Test</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHashtable</span>() <span class="keyword">throws</span> InterruptedException {</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThread; i++) {</div><div class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() {</div><div class="line">                </div><div class="line">                <span class="annotation">@Override</span></div><div class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j++) {</div><div class="line">                        <span class="keyword">int</span> num = xorShift(<span class="keyword">this</span>.hashCode() ^ (<span class="keyword">int</span>) System.nanoTime());</div><div class="line">                        table.put(String.valueOf(num), numj), j);</div><div class="line">                    }</div><div class="line">                    </div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j++) {</div><div class="line">                        <span class="keyword">int</span> num = xorShift(<span class="keyword">this</span>.hashCode() ^ (<span class="keyword">int</span>) System.nanoTime());</div><div class="line">                        table.get(String.valueOf(numj));</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            });</div><div class="line">        }</div><div class="line">        </div><div class="line">        threadPool.shutdown();</div><div class="line">        <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">while</span> (loop) {</div><div class="line">            loop = !threadPool.awaitTermination(<span class="number">10</span>, TimeUnit.MILLISECONDS);</div><div class="line">        }</div><div class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"Hashtable耗时："</span> + (end - start));</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="annotation">@Test</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConcurrentHashMap</span>() <span class="keyword">throws</span> InterruptedException {</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThread; i++) {</div><div class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() {</div><div class="line">                </div><div class="line">                <span class="annotation">@Override</span></div><div class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j++) {</div><div class="line">                        <span class="keyword">int</span> num = xorShift(<span class="keyword">this</span>.hashCode() ^ (<span class="keyword">int</span>) System.nanoTime());</div><div class="line">                        conMap.put(String.valueOf(num), numj), j);</div><div class="line">                    }</div><div class="line">                    </div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j++) {</div><div class="line">                        <span class="keyword">int</span> num = xorShift(<span class="keyword">this</span>.hashCode() ^ (<span class="keyword">int</span>) System.nanoTime());</div><div class="line">                        conMap.get(String.valueOf(numj));</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            });</div><div class="line">        }</div><div class="line">        </div><div class="line">        threadPool.shutdown();</div><div class="line">        <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">while</span> (loop) {</div><div class="line">            loop = !threadPool.awaitTermination(<span class="number">10</span>, TimeUnit.MILLISECONDS);</div><div class="line">        }</div><div class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"ConcurrentHashMap耗时："</span> + (end - start));</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> xorShift(<span class="keyword">int</span> y) {</div><div class="line">        y ^= (y &lt;&lt; <span class="number">6</span>);</div><div class="line">        y ^= (y &gt;&gt;&gt; <span class="number">21</span>);</div><div class="line">        y ^= (y &lt;&lt; <span class="number">7</span>);</div><div class="line">        <span class="keyword">return</span> y;</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<pre><code>当<span class="built_in">count</span> = <span class="number">1000</span>时，结果如下：
    ConcurrentHashMap耗时：<span class="number">44</span>
    Hashtable耗时：<span class="number">14</span>
    MyHashtable耗时：<span class="number">15</span>

当<span class="built_in">count</span> = <span class="number">10000</span>时，结果如下：
    ConcurrentHashMap耗时：<span class="number">1015</span>
    Hashtable耗时：<span class="number">96</span>
    MyHashtable耗时：<span class="number">150</span>

当<span class="built_in">count</span> = <span class="number">100000</span>时，结果如下：
    ConcurrentHashMap耗时：<span class="number">366</span>
    Hashtable耗时：<span class="number">423</span>
    MyHashtable耗时：<span class="number">1002</span>

当<span class="built_in">count</span> = <span class="number">1000000</span>时，结果如下：
    ConcurrentHashMap耗时：<span class="number">3485</span>
    Hashtable耗时：<span class="number">17062</span>
    MyHashtable耗时：<span class="number">114294927</span>
</code></pre><p>当测试足够充分时，结果性能差距非常明显（经过后面的问题发现，MyHashtable性能下降是由于测试用例内存泄露），java.util.concurrent.ConcurrentHashMap性能要优异很多。后面我们将会来优化我们的散列结构性能，减少与java.util.concurrent.ConcurrentHashMap的性能差距。</p>
<h3 id="实现MyConcurrentHashMap">实现MyConcurrentHashMap</h3>
<p>加上同步后，所有对散列的操作都变成了串行操作。首先想到的就是横向优化，将数据分片，每一个Segment的数据单独加锁，这样就可以多线程同时操作。只有多个线程操作的数据哈希映射到同一个Segment中，才会有锁冲突。</p>
<p>首先我们定义一个Segment的内部类，作为一个数据分片，在Segment的对象上单独加锁。</p>
<figure class="highlight [Java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> Segment&lt;K, V&gt; {</div><div class="line">        </div><div class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; [] table;</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这样优化带来一个问题，就是类似于size()和isEmpty()这样的方法会有问题。由于这些方法要遍历每一Segment的数据，如果只是简单的依次把每个Segment的数据的结果相加起来，则难免会造成刚刚统计过的一个Segment后，该Segment马上就发生了变化，最终的结果与当前状态不一致。那么就需要在执行这些操作的时候将所有Segment都加锁，而这种锁操作很显然已经不是内置锁synchronized所能适用。所以我们需要使用显示锁来实现MyConcurrentHashMap。</p>
<figure class="highlight [Java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> Segment&lt;K, V&gt; {</div><div class="line">        </div><div class="line">    final Lock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</div><div class="line">        </div><div class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; [] table;</div><div class="line">        </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</div><div class="line">        </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold;</div><div class="line">        </div><div class="line">    <span class="keyword">private</span> final <span class="keyword">float</span> loadFactor;</div><div class="line">        </div><div class="line">    @SuppressWarnings(<span class="string">"unchecked"</span>)</div><div class="line">    Segment(<span class="keyword">int</span> tableSize, <span class="keyword">float</span> loadFactor) {</div><div class="line">        <span class="keyword">this</span>.table = (Node&lt;K, V&gt; []) (<span class="keyword">new</span> Node [tableSize]);</div><div class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">        threshold = (<span class="keyword">int</span>) (<span class="keyword">this</span>.table.length * loadFactor);</div><div class="line">    }</div><div class="line">    </div><div class="line">    V getValue(<span class="keyword">int</span> hash, Object key) {</div><div class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>();</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="comment">// 从segment中取key对应的value</span></div><div class="line">        } <span class="keyword">finally</span> {</div><div class="line">            <span class="keyword">lock</span>.unlock();</div><div class="line">        }</div><div class="line">    }</div><div class="line">        </div><div class="line">    V putVal(<span class="keyword">int</span> hash, K key, V <span class="keyword">value</span>) {</div><div class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>();</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="comment">// 将key-&gt;value放入segment中</span></div><div class="line">        } <span class="keyword">finally</span> {</div><div class="line">            <span class="keyword">lock</span>.unlock();</div><div class="line">        }</div><div class="line">    }</div><div class="line">        </div><div class="line">    V removeNode(<span class="keyword">int</span> hash, Object key) {</div><div class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>();</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="comment">// 从segment中移除key-&gt;value</span></div><div class="line">        } <span class="keyword">finally</span> {</div><div class="line">            <span class="keyword">lock</span>.unlock();</div><div class="line">        }</div><div class="line">    }</div><div class="line">        </div><div class="line">    <span class="keyword">void</span> clear() {</div><div class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>();</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="comment">// 清除segment中所有数据</span></div><div class="line">        } <span class="keyword">finally</span> {</div><div class="line">            <span class="keyword">lock</span>.unlock();</div><div class="line">        }</div><div class="line">    }</div><div class="line">        </div><div class="line">}</div></pre></td></tr></table></figure>

<p>然后在外部通过将调用请求映射到不同的segment上以减少锁冲突。</p>
<figure class="highlight [Java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConcurrentHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">MyMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>{</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_SEGMENTS = <span class="number">16</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_SEGMENT_SIZE = <span class="number">16</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75</span>f;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Segment&lt;K, V&gt; [] segmentTable;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> loadFactor = DEFAULT_LOAD_FACTOR;</div><div class="line">    </div><div class="line">    <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="keyword">public</span> <span class="title">MyConcurrentHashMap</span>() {</div><div class="line">        <span class="keyword">this</span>.segmentTable = (Segment&lt;K, V&gt; []) (<span class="keyword">new</span> Segment [DEFAULT_SEGMENTS]);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segmentTable.length; i++) {</div><div class="line">            segmentTable[i] = <span class="keyword">new</span> Segment&lt;&gt;(DEFAULT_INITIAL_SEGMENT_SIZE, loadFactor);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> V <span class="title">put</span>(K key, V value) {</div><div class="line">        <span class="keyword">int</span> hash = hash(key);</div><div class="line">        Segment&lt;K, V&gt; s = segmentTable[(segmentTable.length - <span class="number">1</span>) & hash];</div><div class="line">        <span class="keyword">return</span> s.putVal(hash, key, value);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> V <span class="title">remove</span>(Object key) {</div><div class="line">        <span class="keyword">int</span> hash = hash(key);</div><div class="line">        Segment&lt;K, V&gt; s = segmentTable[(segmentTable.length - <span class="number">1</span>) & hash];</div><div class="line">        <span class="keyword">return</span> s.removeNode(hash, key);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span>() {</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segmentTable.length; i++) {</div><div class="line">            segmentTable[i].clear();</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> V <span class="title">get</span>(Object key) {</div><div class="line">        <span class="keyword">int</span> hash = hash(key);</div><div class="line">        Segment&lt;K, V&gt; s = segmentTable[(segmentTable.length - <span class="number">1</span>) & hash];</div><div class="line">        <span class="keyword">return</span> s.getValue(hash, key);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span>() {</div><div class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segmentTable.length; i++) {</div><div class="line">                segmentTable[i].lock.lock();</div><div class="line">                size += segmentTable[i].size;</div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="keyword">return</span> size;</div><div class="line">        } <span class="keyword">finally</span> {</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segmentTable.length; i++) {</div><div class="line">                segmentTable[i].lock.unlock();</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span>() {</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segmentTable.length; i++) {</div><div class="line">                segmentTable[i].lock.lock();</div><div class="line">                <span class="keyword">if</span> (segmentTable[i].size != <span class="number">0</span>) {</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        } <span class="keyword">finally</span> {</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segmentTable.length; i++) {</div><div class="line">                segmentTable[i].lock.unlock();</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span>(Object key) {</div><div class="line">        <span class="keyword">int</span> h;</div><div class="line">        <span class="keyword">return</span> key == <span class="keyword">null</span> ? <span class="number">0</span> : ((h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>));</div><div class="line">    }</div><div class="line">    </div><div class="line">    ......</div><div class="line">}</div></pre></td></tr></table></figure>

<p>但是在完成此优化后，测试结果却很奇怪</p>
<pre><code>当<span class="built_in">count</span> = <span class="number">1000</span>时
    ConcurrentHashMap耗时：<span class="number">30</span>
    Hashtable耗时：<span class="number">11</span>
    MyHashtable耗时：<span class="number">12</span>
    MyConcurrentHashMap耗时：<span class="number">18</span>

当<span class="built_in">count</span> = <span class="number">10000</span>时
    ConcurrentHashMap耗时：<span class="number">118</span>
    Hashtable耗时：<span class="number">111</span>
    MyHashtable耗时：<span class="number">100</span>
    MyConcurrentHashMap耗时：<span class="number">158</span>

当<span class="built_in">count</span> = <span class="number">100000</span>时
    ConcurrentHashMap耗时：<span class="number">450</span>
    Hashtable耗时：<span class="number">305</span>
    MyHashtable耗时：<span class="number">221</span>
    MyConcurrentHashMap耗时：<span class="number">326</span>

当<span class="built_in">count</span> = <span class="number">1000000</span>时
    ConcurrentHashMap耗时：<span class="number">2964</span>
    Hashtable耗时：<span class="number">3228</span>
    MyHashtable耗时：<span class="number">4766</span>
    MyConcurrentHashMap耗时：<span class="number">3366</span>

当<span class="built_in">count</span> = <span class="number">2000000</span>时
    ConcurrentHashMap耗时：<span class="number">5890</span>
    Hashtable耗时：<span class="number">8986</span>
    MyHashtable耗时：<span class="number">9845</span>
    MyConcurrentHashMap耗时：<span class="number">12658</span>
</code></pre><h3 id="测试结果异常分析">测试结果异常分析</h3>
<p>可以看到我们自己实现的MyConcurrentHashMap性能很差，这在理论上应该不成立。</p>
<p>于是我用JProfiler对该单元测试做了性能分析</p>
<p><img src="http://7q5c1f.com1.z0.glb.clouddn.com/QQ20160514-0.png" alt=""></p>
<p>很明显的内存泄露！然后我们在回头看看之前的测试用例代码，几个Map容器在测试完成后都没有释放，真是个低级错误。解决该问题很简单，减少那几个容器的作用域。然后我们对计时做了优化，使用CyclicBarrier使线程池里的线程同时开启和结束，然后来计算开启和结束的时间差。</p>
<figure class="highlight [Java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> MyHashMapMultiThreadTest {</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> ThreadPoolExecutor threadPool;</div><div class="line">    <span class="keyword">private</span> CyclicBarrier startBarrier;</div><div class="line">    <span class="keyword">private</span> CyclicBarrier endBarrier;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">1000</span>; </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nThread = Runtime.getRuntime().availableProcessors() + <span class="number">1</span>;</div><div class="line">    </div><div class="line">    @Before</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span>() {</div><div class="line">        threadPool = <span class="keyword">new</span> ThreadPoolExecutor(nThread, nThread, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">        startBarrier = <span class="keyword">new</span> CyclicBarrier(nThread + <span class="number">1</span>);</div><div class="line">        endBarrier = <span class="keyword">new</span> CyclicBarrier(nThread + <span class="number">1</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    @Test</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMyHashTable</span>() throws InterruptedException, BrokenBarrierException {</div><div class="line">        final MyMap&lt;String, Integer&gt; myTable = <span class="keyword">new</span> MyHashtable&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThread; i++) {</div><div class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() {</div><div class="line">                </div><div class="line">                @Override</div><div class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">                    <span class="keyword">try</span> {</div><div class="line">                        startBarrier.<span class="keyword">await</span>();</div><div class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j++) {</div><div class="line">                            myTable.put(String.valueOf(j), j);</div><div class="line">                            myTable.<span class="keyword">get</span>(String.valueOf(j));</div><div class="line">                        }</div><div class="line">                        endBarrier.<span class="keyword">await</span>();</div><div class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">                        e.printStackTrace();</div><div class="line">                    } <span class="keyword">catch</span> (BrokenBarrierException e) {</div><div class="line">                        e.printStackTrace();</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            });</div><div class="line">        }</div><div class="line">        </div><div class="line">        threadPool.shutdown();</div><div class="line">        </div><div class="line">        startBarrier.<span class="keyword">await</span>();</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        endBarrier.<span class="keyword">await</span>();</div><div class="line">        <span class="keyword">long</span> time = System.currentTimeMillis() - start;</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"MyHashtable耗时："</span> + time);</div><div class="line">    }</div><div class="line">    </div><div class="line">    @Test</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMyConcurrentHashMap</span>() throws InterruptedException, BrokenBarrierException {</div><div class="line">        final MyMap&lt;String, Integer&gt; myConMap = <span class="keyword">new</span> MyConcurrentHashMap&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThread; i++) {</div><div class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() {</div><div class="line">                </div><div class="line">                @Override</div><div class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">                    <span class="keyword">try</span> {</div><div class="line">                        startBarrier.<span class="keyword">await</span>();</div><div class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j++) {</div><div class="line">                            myConMap.put(String.valueOf(j), j);</div><div class="line">                            myConMap.<span class="keyword">get</span>(String.valueOf(j));</div><div class="line">                        }</div><div class="line">                        startBarrier.<span class="keyword">await</span>();</div><div class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">                        e.printStackTrace();</div><div class="line">                    } <span class="keyword">catch</span> (BrokenBarrierException e) {</div><div class="line">                        e.printStackTrace();</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            });</div><div class="line">        }</div><div class="line">        </div><div class="line">        threadPool.shutdown();</div><div class="line">        </div><div class="line">        startBarrier.<span class="keyword">await</span>();</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        endBarrier.<span class="keyword">await</span>();</div><div class="line">        <span class="keyword">long</span> time = System.currentTimeMillis() - start;</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"MyConcurrentHashMap耗时："</span> + time);</div><div class="line">    }</div><div class="line">    </div><div class="line">    @Test</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHashtable</span>() throws InterruptedException, BrokenBarrierException {</div><div class="line">        final Map&lt;String, Integer&gt; table = <span class="keyword">new</span> Hashtable&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThread; i++) {</div><div class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() {</div><div class="line">                </div><div class="line">                @Override</div><div class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">                    <span class="keyword">try</span> {</div><div class="line">                        startBarrier.<span class="keyword">await</span>();</div><div class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j++) {</div><div class="line">                            table.put(String.valueOf(j), j);</div><div class="line">                            table.<span class="keyword">get</span>(String.valueOf(j));</div><div class="line">                        }</div><div class="line">                        endBarrier.<span class="keyword">await</span>();</div><div class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">                        e.printStackTrace();</div><div class="line">                    } <span class="keyword">catch</span> (BrokenBarrierException e) {</div><div class="line">                        e.printStackTrace();</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            });</div><div class="line">        }</div><div class="line">        </div><div class="line">        threadPool.shutdown();</div><div class="line">        </div><div class="line">        startBarrier.<span class="keyword">await</span>();</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        endBarrier.<span class="keyword">await</span>();</div><div class="line">        <span class="keyword">long</span> time = System.currentTimeMillis() - start;</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Hashtable耗时："</span> + time);</div><div class="line">    }</div><div class="line">    </div><div class="line">    @Test</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConcurrentHashMap</span>() throws InterruptedException, BrokenBarrierException {</div><div class="line">        final Map&lt;String, Integer&gt; conMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThread; i++) {</div><div class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() {</div><div class="line">                </div><div class="line">                @Override</div><div class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">                    <span class="keyword">try</span> {</div><div class="line">                        startBarrier.<span class="keyword">await</span>();</div><div class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j++) {</div><div class="line">                            conMap.put(String.valueOf(j), j);</div><div class="line">                            conMap.<span class="keyword">get</span>(String.valueOf(j));</div><div class="line">                        }</div><div class="line">                        endBarrier.<span class="keyword">await</span>();</div><div class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">                        e.printStackTrace();</div><div class="line">                    } <span class="keyword">catch</span> (BrokenBarrierException e) {</div><div class="line">                        e.printStackTrace();</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            });</div><div class="line">        }</div><div class="line">        </div><div class="line">        threadPool.shutdown();</div><div class="line">        </div><div class="line">        startBarrier.<span class="keyword">await</span>();</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        endBarrier.<span class="keyword">await</span>();</div><div class="line">        <span class="keyword">long</span> time = System.currentTimeMillis() - start;</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"ConcurrentHashMap耗时："</span> + time);</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>该测试用例测试出的结果如下：</p>
<pre><code>当<span class="built_in">count</span> = <span class="number">1000</span>时
    ConcurrentHashMap耗时：<span class="number">27</span>
    Hashtable耗时：<span class="number">11</span>
    MyHashtable耗时：<span class="number">10</span>
    MyConcurrentHashMap耗时：<span class="number">11</span>

当<span class="built_in">count</span> = <span class="number">10000</span>时
    ConcurrentHashMap耗时：<span class="number">101</span>
    Hashtable耗时：<span class="number">99</span>
    MyHashtable耗时：<span class="number">107</span>
    MyConcurrentHashMap耗时：<span class="number">95</span>

当<span class="built_in">count</span> = <span class="number">100000</span>时
    ConcurrentHashMap耗时：<span class="number">349</span>
    Hashtable耗时：<span class="number">278</span>
    MyHashtable耗时：<span class="number">307</span>
    MyConcurrentHashMap耗时：<span class="number">218</span>

当<span class="built_in">count</span> = <span class="number">1000000</span>时
    ConcurrentHashMap耗时：<span class="number">2048</span>
    Hashtable耗时：<span class="number">3474</span>
    MyHashtable耗时：<span class="number">2706</span>
    MyConcurrentHashMap耗时：<span class="number">1836</span>

当<span class="built_in">count</span> = <span class="number">2000000</span>时
    ConcurrentHashMap耗时：<span class="number">14822</span>
    Hashtable耗时：<span class="number">20524</span>
    MyHashtable耗时：<span class="number">20953</span>
    MyConcurrentHashMap耗时：<span class="number">15960</span>

当<span class="built_in">count</span> = <span class="number">10000000</span>时
    ConcurrentHashMap耗时：<span class="number">32578</span>
    Hashtable耗时：<span class="number">43989</span>
    MyHashtable耗时：<span class="number">50393</span>
    MyConcurrentHashMap耗时：<span class="number">35399</span>
</code></pre><p>测试结果表明，我们的MyConcurrentHashMap性能有很大的优势。但是要确定我们的横向优化起了作用，还需要用JProfiler再观察一下运行时阻塞的线程</p>
<p><img src="http://7q5c1f.com1.z0.glb.clouddn.com/QQ20160514-2.png" alt=""></p>
<p>该图是执行过程中线程执行情况，两边分别是ConcurrentHashMap和MyConcurrentHashMap，中间是Hashtable和MyHashtable，可以看到，系统的ConcurrentHashMap和我们的MyConcurrentHashMap确实锁竞争明显比Hashtable和MyHashtable少。</p>
<h2 id="java-util-concurrent-ConcurrentHashMap源码分析">java.util.concurrent.ConcurrentHashMap源码分析</h2>
<p>我们实现了自己的HashMap和ConcurrentHashMap，虽然还很粗糙，但是基本说明了他们的原理。然而，Java本身的ConcurrentHashMap还有更多的细节，我们现在来看JDK的源码，逐步分析这些源码。本文源码基于JDK 1.7的ConcurrentHashMap源码。</p>
<h3 id="concurrentLevel">concurrentLevel</h3>
<p>ConcurrentHashMap可以通过初始化时的concurrentLevel参数控制segment的数量，默认值为16。</p>
<figure class="highlight [Java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span>(<span class="keyword">int</span> initialCapacity,</div><div class="line">                             <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel) {</div><div class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</div><div class="line">        concurrencyLevel = MAX_SEGMENTS;</div><div class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></div><div class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> ssize = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) {</div><div class="line">        ++sshift;</div><div class="line">        ssize &lt;&lt;= <span class="number">1</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</div><div class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">        initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;</div><div class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</div><div class="line">        ++c;</div><div class="line">    <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</div><div class="line">    <span class="keyword">while</span> (cap &lt; c)</div><div class="line">        cap &lt;&lt;= <span class="number">1</span>;</div><div class="line">    <span class="comment">// create segments and segments[0]</span></div><div class="line">    Segment&lt;K,V&gt; s0 =</div><div class="line">        <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</div><div class="line">                        (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</div><div class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</div><div class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></div><div class="line">    <span class="keyword">this</span>.segments = ss;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>由于ConcurrentHashMap是每个segment单独加锁，所以concurrentLevel越大，segment数量越多，支持同时操作的线程数就越多，并发程度就越高。但是，如果concurrentLevel设置过大，会导致内存资源的浪费；然而，设置的过小，也会导致线程间竞争更激烈，导致并发性能差。</p>
<h3 id="putOrderedObject">putOrderedObject</h3>
<p>ConcurrentHashMap中segment的table字段和每个Entry中的next字段用的是putOrderedObject设置。</p>
<figure class="highlight [Java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line"> * Sets next field with volatile write semantics.  (See above</div><div class="line"> * about use of putOrderedObject.)</div><div class="line"> */</div><div class="line"><span class="keyword">final</span> <span class="keyword">void</span> setNext(HashEntry&lt;K,V&gt; n) {</div><div class="line">    UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, n);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="javadoc">/**</span></div><div class="line"> * Sets the ith element of given table, with volatile write</div><div class="line"> * semantics. (See above about use of putOrderedObject.)</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="keyword">void</span> setEntryAt(HashEntry&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</div><div class="line">                                   HashEntry&lt;K,V&gt; e) {</div><div class="line">    UNSAFE.putOrderedObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; TSHIFT) + TBASE, e);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>putOrderedObject是sun.misc.Unsafe提供的一系列lazySet方法之一，该方法只能用在volatile字段。lazySet比直接复制更接近底层，效率更高，而且可以保证在锁释放的时候其他线程可见。</p>
<h3 id="更充分的hash">更充分的hash</h3>
<p>ConcurrentHashMap改进了hash方法，使用了Wang/Jenkins的变种算法对hashCode进行再次hash，保证key可以尽量均匀的映射到每个segment。因为在某些极端情况下，hashCode方法实现的不好，会导致某些segment负载过重，进而并发性能下降。</p>
<figure class="highlight [Java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line"> * Applies a supplemental hash function to a given hashCode, which</div><div class="line"> * defends against poor quality hash functions.  This is critical</div><div class="line"> * because ConcurrentHashMap uses power-of-two length hash tables,</div><div class="line"> * that otherwise encounter collisions for hashCodes that do not</div><div class="line"> * differ in lower or upper bits.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span>(Object k) {</div><div class="line">    <span class="keyword">int</span> h = hashSeed;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((<span class="number">0</span> != h) && (k <span class="keyword">instanceof</span> String)) {</div><div class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</div><div class="line">    }</div><div class="line"></div><div class="line">    h ^= k.hashCode();</div><div class="line"></div><div class="line">    <span class="comment">// Spread bits to regularize both segment and index locations,</span></div><div class="line">    <span class="comment">// using variant of single-word Wang/Jenkins hash.</span></div><div class="line">    h += (h &lt;&lt;  <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</div><div class="line">    h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</div><div class="line">    h += (h &lt;&lt;   <span class="number">3</span>);</div><div class="line">    h ^= (h &gt;&gt;&gt;  <span class="number">6</span>);</div><div class="line">    h += (h &lt;&lt;   <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</div><div class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Segment的put方法">Segment的put方法</h3>
<p>put方法首先尝试请求锁，如果请求不到就自旋等待一段时间后，如果等待到锁就继续执行，如果没有等到就调用lock方法阻塞线程等待锁。然后查找key对应的Entry，如果找到就执行更新操作，如果没有找到就新增，当segment中的Entry数量超过阈值就将该segment的空间空大一倍并进行rehash。</p>
<figure class="highlight [Java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> V put(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent) {</div><div class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</div><div class="line">        scanAndLockForPut(key, hash, value);</div><div class="line">    V oldValue;</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        HashEntry&lt;K,V&gt;[] tab = table;</div><div class="line">        <span class="keyword">int</span> <span class="keyword">index</span> = (tab.length - <span class="number">1</span>) & hash;</div><div class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, <span class="keyword">index</span>);</div><div class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) {</div><div class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) {</div><div class="line">                K k;</div><div class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</div><div class="line">                    (e.hash == hash && key.equals(k))) {</div><div class="line">                    oldValue = e.value;</div><div class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) {</div><div class="line">                        e.value = value;</div><div class="line">                        ++modCount;</div><div class="line">                    }</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                }</div><div class="line">                e = e.next;</div><div class="line">            }</div><div class="line">            <span class="keyword">else</span> {</div><div class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</div><div class="line">                    node.setNext(first);</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</div><div class="line">                <span class="keyword">int</span> c = <span class="keyword">count</span> + <span class="number">1</span>;</div><div class="line">                <span class="keyword">if</span> (c &gt; threshold && tab.length &lt; MAXIMUM_CAPACITY)</div><div class="line">                    rehash(node);</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    setEntryAt(tab, <span class="keyword">index</span>, node);</div><div class="line">                ++modCount;</div><div class="line">                <span class="keyword">count</span> = c;</div><div class="line">                oldValue = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    } <span class="keyword">finally</span> {</div><div class="line">        unlock();</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>put方法可能会对原有结构有更新操作的字段是HashEntry中的value字段、Segment的table的某个元素和Segment的table，三个字段。而这三个字段都是volatile字段，同时这些更新不会破坏数据结构，那么只要unlock后，其他线程马上就可以看到最新结果。就算在更新时有其他线程在使用get操作，要么会获取到最新结果，要么会获取到旧结果，并不会出现无法预料的结果。</p>
<h3 id="自旋等等锁">自旋等等锁</h3>
<p>ConcurrentHashMap在put之前会调用scanAndLockForPut来自旋等待锁。首先反复的调用tryLock来请求锁，同时遍历key对应的HashEntry链表寻找相应的HashEntry，如果没找到就创建一个新的HashEntry。而且每遍历一个节点检查该HashEntry链表是否有变化，如果有变化就重新开始遍历。然后通过retries来控制不让自旋一直进行下去。</p>
<figure class="highlight [Java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line"> * Scans for a node containing given key while trying to</div><div class="line"> * acquire lock, creating and returning one if not found. Upon</div><div class="line"> * return, guarantees that lock is held. UNlike in most</div><div class="line"> * methods, calls to method equals are not screened: Since</div><div class="line"> * traversal speed doesn't matter, we might as well help warm</div><div class="line"> * up the associated code and accesses as well.</div><div class="line"> *</div><div class="line"> *<span class="javadoctag"> @return</span> a new node if key not found, else null</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span>(K key, <span class="keyword">int</span> hash, V value) {</div><div class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</div><div class="line">    HashEntry&lt;K,V&gt; e = first;</div><div class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></div><div class="line">    <span class="keyword">while</span> (!tryLock()) {</div><div class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></div><div class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) {</div><div class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) {</div><div class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></div><div class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                retries = <span class="number">0</span>;</div><div class="line">            }</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</div><div class="line">                retries = <span class="number">0</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                e = e.next;</div><div class="line">        }</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) {</div><div class="line">            lock();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries & <span class="number">1</span>) == <span class="number">0</span> &&</div><div class="line">                 (f = entryForHash(<span class="keyword">this</span>, hash)) != first) {</div><div class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></div><div class="line">            retries = -<span class="number">1</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用自旋等待是为了降低线程切换锁消耗的资源，因为一个线程可能只需要很短时间就可以获取到锁，但是lock方法会阻塞线程，导致额外的线程切换浪费性能。scanAndLockForPut在自旋等待过程中同时尝试为put操作做一些准备，让后续的put操作有可能少做一些操作。而scanAndLock就只是单纯的自旋等待。</p>
<h3 id="get方法">get方法</h3>
<p>由于put方法保证了更新不会破坏数据结构，而且保证了可见性，所以get方法并没有加锁。而segment数组用的volatile方式读取，而且写操作用的是CAS，保证了segment的延迟初始化线程安全。</p>
<figure class="highlight [Java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Returns the value to which the specified key <span class="keyword">is</span> mapped,</div><div class="line"> * <span class="keyword">or</span> {<span class="property">@code</span> <span class="literal">null</span>} <span class="keyword">if</span> <span class="keyword">this</span> map contains <span class="literal">no</span> mapping <span class="keyword">for</span> the key.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;More formally, <span class="keyword">if</span> <span class="keyword">this</span> map contains a mapping from a key</div><div class="line"> * {<span class="property">@code</span> k} to a value {<span class="property">@code</span> v} such that {<span class="property">@code</span> key.equals(k)},</div><div class="line"> * <span class="keyword">then</span> <span class="keyword">this</span> method returns {<span class="property">@code</span> v}; otherwise it returns</div><div class="line"> * {<span class="property">@code</span> <span class="literal">null</span>}.  (There can be at most one such mapping.)</div><div class="line"> *</div><div class="line"> * <span class="property">@throws</span> NullPointerException <span class="keyword">if</span> the specified key <span class="keyword">is</span> <span class="literal">null</span></div><div class="line"> */</div><div class="line">public V get(Object key) {</div><div class="line">    Segment&lt;K,V&gt; s; <span class="regexp">//</span> manually integrate access methods to reduce overhead</div><div class="line">    HashEntry&lt;K,V&gt;[] tab;</div><div class="line">    int h = hash(key);</div><div class="line">    long u = (((h &gt;&gt;&gt; segmentShift) & segmentMask) &lt;&lt; SSHIFT) + SBASE;</div><div class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="literal">null</span> &&</div><div class="line">        (tab = s.table) != <span class="literal">null</span>) {</div><div class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</div><div class="line">                 (tab, ((long)(((tab.length - <span class="number">1</span>) & h)) &lt;&lt; TSHIFT) + TBASE);</div><div class="line">             e != <span class="literal">null</span>; e = e.next) {</div><div class="line">            K k;</div><div class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h && key.equals(k)))</div><div class="line">                <span class="keyword">return</span> e.value;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="size方法">size方法</h3>
<p>首先，ConcurrentHashMap在每次对一个Segment做更新操作时会使用modeCount字段来记录操作次数。size方法会不断统计所有Segment的size和modeCount，如果两次modeCount没有发生变化，说明这段时间ConcurrentHashMap没有更新操作，那么就直接返回size汇总。但是如果竞争激烈，会导致ConcurrentHashMap的size一直变化，所以在size方法里面，当统计size失败一定次数后，就依次把每个segment加锁，再进行汇总。</p>
<figure class="highlight [Java]"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line"> * Returns the number of key-value mappings in this map.  If the</div><div class="line"> * map contains more than &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt; elements, returns</div><div class="line"> * &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt;.</div><div class="line"> *</div><div class="line"> *<span class="javadoctag"> @return</span> the number of key-value mappings in this map</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span>() {</div><div class="line">    <span class="comment">// Try a few times to get accurate count. On failure due to</span></div><div class="line">    <span class="comment">// continuous async changes in table, resort to locking.</span></div><div class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</div><div class="line">    <span class="keyword">int</span> size;</div><div class="line">    <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></div><div class="line">    <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></div><div class="line">    <span class="keyword">long</span> last = <span class="number">0</span>L;   <span class="comment">// previous sum</span></div><div class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="keyword">for</span> (;;) {</div><div class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) {</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</div><div class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></div><div class="line">            }</div><div class="line">            sum = <span class="number">0</span>L;</div><div class="line">            size = <span class="number">0</span>;</div><div class="line">            overflow = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) {</div><div class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</div><div class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) {</div><div class="line">                    sum += seg.modCount;</div><div class="line">                    <span class="keyword">int</span> c = seg.count;</div><div class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</div><div class="line">                        overflow = <span class="keyword">true</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (sum == last)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            last = sum;</div><div class="line">        }</div><div class="line">    } <span class="keyword">finally</span> {</div><div class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) {</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</div><div class="line">                segmentAt(segments, j).unlock();</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这样设计的原因在于，大部分情况下直接统计size就是正确结果，而给每个segment加锁是一个效率很低的操作。而且，通过retries防止size方法始终无法返回。</p>
<h2 id="总结">总结</h2>
<p>java.util.concurrent.ConcurrentHashMap为了性能做了很多优化，但是关键还是以下几点：</p>
<ol>
<li>锁分段</li>
<li>减少锁持有的时间</li>
<li>减少线程切换</li>
</ol>
<p>ConcurrentHashMap只是JDK的一个类，但是这些思想却是通用的。不仅在并发编程过程中，而且在整个系统架构中，也会有类似的思路，比如我们经常会根据数据的hash值将计算分布到多个计算节点上，以求负载均衡；还有优化代码来减少计算时间，使整体性能更高。</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Java/">Java</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Java/">Java</a>
  </div>

</div>


<div class="article-share" id="share">

  <div data-url="http://elvin.im/2016/04/17/java-util-concurrent-ConcurrentHashMap原理研究/" data-title="java.util.concurrent.ConcurrentHashMap原理研究 | Elvin Blog" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2016/05/04/Java常用集合类数据结构/" title="Java常用集合类数据结构">
  <strong>上一篇：</strong><br/>
  <span>
  Java常用集合类数据结构</span>
</a>
</div>


<div class="next">
<a href="/2016/02/04/【译】Java垃圾回收/"  title="【译】Java垃圾回收">
 <strong>下一篇：</strong><br/> 
 <span>【译】Java垃圾回收
</span>
</a>
</div>

</nav>

	
<section class="comment">
	<div class="ds-thread"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#非线程安全HashMap"><span class="toc-number">1.</span> <span class="toc-text">非线程安全HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实现MyHashMap"><span class="toc-number">1.1.</span> <span class="toc-text">实现MyHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#put方法性能"><span class="toc-number">1.2.</span> <span class="toc-text">put方法性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自适应容量优化"><span class="toc-number">1.3.</span> <span class="toc-text">自适应容量优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get方法性能"><span class="toc-number">1.4.</span> <span class="toc-text">get方法性能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程安全的HashMap"><span class="toc-number">2.</span> <span class="toc-text">线程安全的HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#改造MyHashMap为线程安全"><span class="toc-number">2.1.</span> <span class="toc-text">改造MyHashMap为线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试MyHashtable性能"><span class="toc-number">2.2.</span> <span class="toc-text">测试MyHashtable性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现MyConcurrentHashMap"><span class="toc-number">2.3.</span> <span class="toc-text">实现MyConcurrentHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试结果异常分析"><span class="toc-number">2.4.</span> <span class="toc-text">测试结果异常分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java-util-concurrent-ConcurrentHashMap源码分析"><span class="toc-number">3.</span> <span class="toc-text">java.util.concurrent.ConcurrentHashMap源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#concurrentLevel"><span class="toc-number">3.1.</span> <span class="toc-text">concurrentLevel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#putOrderedObject"><span class="toc-number">3.2.</span> <span class="toc-text">putOrderedObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更充分的hash"><span class="toc-number">3.3.</span> <span class="toc-text">更充分的hash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Segment的put方法"><span class="toc-number">3.4.</span> <span class="toc-text">Segment的put方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自旋等等锁"><span class="toc-number">3.5.</span> <span class="toc-text">自旋等等锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get方法"><span class="toc-number">3.6.</span> <span class="toc-text">get方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#size方法"><span class="toc-number">3.7.</span> <span class="toc-text">size方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/Android/" title="Android">Android<sup>3</sup></a></li>
		
			<li><a href="/categories/Hadoop/" title="Hadoop">Hadoop<sup>1</sup></a></li>
		
			<li><a href="/categories/Java/" title="Java">Java<sup>6</sup></a></li>
		
			<li><a href="/categories/JavaScript/" title="JavaScript">JavaScript<sup>1</sup></a></li>
		
			<li><a href="/categories/Linux/" title="Linux">Linux<sup>3</sup></a></li>
		
			<li><a href="/categories/Maven/" title="Maven">Maven<sup>1</sup></a></li>
		
			<li><a href="/categories/MySQL/" title="MySQL">MySQL<sup>1</sup></a></li>
		
			<li><a href="/categories/Windows/" title="Windows">Windows<sup>1</sup></a></li>
		
			<li><a href="/categories/github/" title="github">github<sup>1</sup></a></li>
		
			<li><a href="/categories/数据库/" title="数据库">数据库<sup>1</sup></a></li>
		
			<li><a href="/categories/机器学习/" title="机器学习">机器学习<sup>1</sup></a></li>
		
			<li><a href="/categories/浏览器兼容性/" title="浏览器兼容性">浏览器兼容性<sup>1</sup></a></li>
		
			<li><a href="/categories/算法实现/" title="算法实现">算法实现<sup>5</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/Java/" title="Java">Java<sup>3</sup></a></li>
		
			<li><a href="/tags/Android/" title="Android">Android<sup>3</sup></a></li>
		
			<li><a href="/tags/Java-POI/" title="Java POI">Java POI<sup>2</sup></a></li>
		
			<li><a href="/tags/无线网络共享-Windows/" title="无线网络共享 Windows">无线网络共享 Windows<sup>1</sup></a></li>
		
			<li><a href="/tags/快速排序/" title="快速排序">快速排序<sup>1</sup></a></li>
		
			<li><a href="/tags/并查集/" title="并查集">并查集<sup>1</sup></a></li>
		
			<li><a href="/tags/寻找第k小元素/" title="寻找第k小元素">寻找第k小元素<sup>1</sup></a></li>
		
			<li><a href="/tags/寻找多数元素/" title="寻找多数元素">寻找多数元素<sup>1</sup></a></li>
		
			<li><a href="/tags/Hibernate-注入/" title="Hibernate 注入">Hibernate 注入<sup>1</sup></a></li>
		
			<li><a href="/tags/Hexo-github/" title="Hexo github">Hexo github<sup>1</sup></a></li>
		
			<li><a href="/tags/Hadoop-Docker/" title="Hadoop Docker">Hadoop Docker<sup>1</sup></a></li>
		
			<li><a href="/tags/Java-垃圾回收/" title="Java 垃圾回收">Java 垃圾回收<sup>1</sup></a></li>
		
			<li><a href="/tags/CentOS-Linux/" title="CentOS Linux">CentOS Linux<sup>1</sup></a></li>
		
			<li><a href="/tags/MySQL-数据库-索引/" title="MySQL 数据库 索引">MySQL 数据库 索引<sup>1</sup></a></li>
		
			<li><a href="/tags/Maven-Nexus/" title="Maven Nexus">Maven Nexus<sup>1</sup></a></li>
		
			<li><a href="/tags/JavaScript-闭包-ExtJS/" title="JavaScript 闭包 ExtJS">JavaScript 闭包 ExtJS<sup>1</sup></a></li>
		
			<li><a href="/tags/浏览器兼容性/" title="浏览器兼容性">浏览器兼容性<sup>1</sup></a></li>
		
			<li><a href="/tags/HTML/" title="HTML">HTML<sup>1</sup></a></li>
		
			<li><a href="/tags/JS/" title="JS">JS<sup>1</sup></a></li>
		
			<li><a href="/tags/机器学习/" title="机器学习">机器学习<sup>1</sup></a></li>
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
      <li><a href="http://lpbobo.com" target="_blank" title="Leo">LP's Blog</a></li>
      <li><a href="http://hexo.io" target="_blank" title="Hexo">Hexo</a></li>
    </ul>
</div>


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Pacman">Jacman</a> © 2016 
		
		<a href="http://elvin.im/about" target="_blank" title="Elvin Guan">Elvin Guan</a>
		
		</p>
</div>

<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F9cc4c1668f1879156c0627818f4e84ae' type='text/javascript'%3E%3C/script%3E"));
</script>

</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"elvin-blog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>





<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<script src="/js/totop.js"></script>




  </body>
</html>
